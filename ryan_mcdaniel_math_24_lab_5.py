# -*- coding: utf-8 -*-
"""Ryan McDaniel Math 24 Lab 5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EU4XFYVgxO9UiqAtF-712QrdD4p2my8H
"""

import matplotlib.pyplot as plt
from PIL import Image
import imageio.v2 as imageio



def plot(x): #make a function for plotting
    fig, ax = plt.subplots()
    im = ax.imshow(x,cmap='gray') #make sure we use
    ax.axis('off') #turn the axis off on the grids
    fig.set_size_inches(20, 20)
    plt.show()

im = imageio.imread('https://lospec.com/palette-list/st-64-natural-1x.png')

im

plot(im)

im.shape #the image is a tensor 1x64x3, Tensor is a three dimensional array, point is 0d, vector is 1d, matrix 2d, and tensor 3d or higher

im[0:1,40:41,:] #find the vector of the third dimension of the tensor at (1,41) in the x and y dimensions

plot(im[:,40:41,:]) #it's this pixel of the image

im[:,40:41,:]

im = imageio.imread('https://lospec.com/palette-list/waverator-1x.png') #get another tensor for our color pallette

plot(im)

im #here we see the full tensor.  it is easily seen in two dimensions because the first dimension is only of size 1, but it is in fact a 3 dimensional tensor



import numpy as np
import matplotlib.pyplot as plt

# Binary image
binary_image = np.array([
    [0, 1, 0],
    [1, 1, 1],
    [0, 1, 0]
])

binary_image #lets create a matrix where 1 represents the highest brightness and 0 the lowest brightness

plt.imshow(binary_image, cmap='gray') #if we plot this on a gray colormap, we can see that it presents by default as black where binary_image == 0, and white where it == 1

plt.imshow(binary_image, cmap='viridis') #in the viridis colormap, we see that the highest brightness value presents as yellow and the lowest as purple.  Our values do not correspond to specific colors but rather levels of brightness in our data

# Grayscale image
grayscale_image = np.array([ #lets create another matrix with values between 0 and 255
    [50, 100, 150],
    [200, 255, 200],
    [150, 100, 50]
])
plt.imshow(grayscale_image, cmap='gray', vmin=0, vmax=255) #in matplotlib plot we can specify our value minimum and maximum, which will plot values between these as a gradient of the colormap between the brightest and darkest values

plt.imshow(grayscale_image, cmap='plasma', vmin=0, vmax=255) #we demonstrate again that changing the colormap changes the appearance of the data, but not the data itself, which corresponds to brightness values
#other data that is not from color or brightness can be easily translated to a colormap to represent values using this method

# Grayscale image
grayscale_image = np.array([ #by default, our values will be between 1 and 0, so changing the vmax and vmin is the method to use if we have data between two specific values
    [0.2, 0.4, 0.6],
    [0.8, 1.0, 0.8],
    [0.6, 0.4, 0.2]
])
plt.imshow(grayscale_image, cmap='gray')

# RGB image
rgb_image = np.array([ #images are tensors with three dimensions, not just matrices, by default there are three color matrices which are the red, green, and blue (RGB)
    [[255, 0, 0], [0, 255, 0], [0, 0, 255]],
    [[255, 255, 0], [0, 255, 255], [255, 0, 255]],
    [[128, 128, 128], [255, 255, 255], [0, 0, 0]] #more matrices can be added for different types of data, or even greater dimensions of images for data that is n dimensional
])

rgb_image #this is the data in our rgb image, which demonstrates that all images are just tensors of information

plt.imshow(rgb_image) #using imshow we show an image, since it is a tensor, we don't need to specify a colormap for our third dimension

# RGB image
rgb_image = np.array([ #colormap using percentage values rather than 0-255,
    [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
    [[1, 1, 0], [0, 1, 1], [1, 0, 1]],
    [[0.5, 0.5, 0.5], [1, 1, 1], [0, 0, 0]]
])

# RGB image
# rgb_image = np.array([
#     [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
#     [[1, 1, 0], [0, 1, 1], [1, 0, 1]],

# ])

"""This color map shows what happens when you max specific values and minimize others.

Maxxing out the Red color channel with zero Blue or Green will give us Red.
Maxxing out the Green channel with no Red or Blue will give us Green.
Maxxing out the Blue channel with no Red or Green will give us Dark Blue.
Maxxing Red and Green channels without Blue gives yellow.
Maxxing out Green and Blue but no Red gives us Cyan.
Maxxing out Red and Blue but no Green gives us Magenta.
Giving an average value for all color channels gives Gray.
Maxxing all three gives White.
Having Zero in all channels gives black.
"""

rgb_image

plt.imshow(rgb_image*255)



x = np.zeros((2,2,3))
x[:,:,0] = 1
plt.imshow(x)

x = np.zeros((2,2,3))
x[:,:,1] = 1
plt.imshow(x)

x = np.zeros((2,2,3))
x[:,:,2] = 1
plt.imshow(x)

x = np.zeros((2,2,3))
x[:,:,0] = 1
x[:,:,1] = 1
plt.imshow(x)

x = np.zeros((2,2,3))
x[:,:,1] = 1
x[:,:,2] = 1
plt.imshow(x)

x = np.zeros((2,2,3))
x[:,:,0] = 1
x[:,:,2] = 1
plt.imshow(x)

x = np.zeros((2,2,3))
x[:,:,0] = 0.5
x[:,:,1] = 0.5
x[:,:,2] = 0.5
plt.imshow(x)

x = np.zeros((2,2,3))
x[:,:,0] = 1
x[:,:,1] = 1
x[:,:,2] = 1
plt.imshow(x)

x = np.zeros((2,2,3))
x[:,:,0] = 0
x[:,:,1] = 0
x[:,:,2] = 0
plt.imshow(x)



r = np.random.rand()

r



r = np.random.rand() #we can get a random color by randomly generating values for each r g and b value.
g = np.random.rand()
b = np.random.rand()


x = np.zeros((2,2,3)) #then we generate an empty matrix and put each r g and b value into their respective spots.

x[:,:,0] = r
x[:,:,1] = g
x[:,:,2] = b


plt.imshow(x) #lets see our random color!



for i in range(5): #putting this in a for loop will generate multiple random colors

    z = np.ones((10,10,3)) #first we create a 10x10 pixel matrix (it can be zeroes or ones, we are going to replace all the values anyway)

    r = np.random.rand() #create random values for each color channel
    g = np.random.rand()
    b = np.random.rand()

    print(r,g,b) #this will show the random r g and b values above each random color

    z[:,:,0] = r #these put each random value into our matrix.  Each layer of the matrix is uniform 10x10
    z[:,:,1] = g
    z[:,:,2] = b

    plt.imshow(z); #plot the image
    plt.show() #show the plot

"""The next section will show us how to find the opposite of a color and average them out to get their average value."""





for i in range(5): #for loop to do this 5 times

    z1 = np.ones((10,10,3)) #create two 10x10x3 matrices
    z2 = np.ones((10,10,3))

    r = np.random.rand() #create random values for r g and b for our first color ONLY
    g = np.random.rand()
    b = np.random.rand()

    z1[:,:,0] = r #we put the r g and b values into our first color
    z1[:,:,1] = g
    z1[:,:,2] = b

    z2[:,:,0] = 1-r #since our values are in between 0 and 1 we can subtract each from one to get the opposite value of r g b in the first color, and put them into our second color
    z2[:,:,1] = 1-g
    z2[:,:,2] = 1-b

    z3 = np.hstack((z1,z2)) #this function will horizontally stack the two matrices together to form one 10x20x3 matrix

    plt.imshow(z3); #plot the bigger matrix
    plt.show() #show our plot

"""The next section will generate two random numbers and average them out."""



z1 = np.ones((10,10,3)) #generate first matrix
z1[:,:,0] = np.random.rand() #insert random color channel values
z1[:,:,1] = np.random.rand()
z1[:,:,2] = np.random.rand()

z2 = np.ones((10,10,3)) #generate second matrix
z2[:,:,0] = np.random.rand() #insert random color channel values
z2[:,:,1] = np.random.rand()
z2[:,:,2] = np.random.rand()

zavg = (z1+z2)/2 #doing a normal math operation on a matrix will do each value individually with the corresponding value of the opposite matrix
#here we do the average of each into a new matrix

z3 = np.hstack((z1,zavg,z2)) #we stack the matrices with the average inbetween

plt.imshow(z3); #plot the new matrix
plt.show() #show the plot



z1 = np.ones((10,10,3)) #this function does the exact same thing, except adds an average of the average and each color
z1[:,:,0] = np.random.rand() #random color 1
z1[:,:,1] = np.random.rand()
z1[:,:,2] = np.random.rand()

z2 = np.ones((10,10,3))
z2[:,:,0] = np.random.rand() #random color 2
z2[:,:,1] = np.random.rand()
z2[:,:,2] = np.random.rand()

zavg = (z1+z2)/2 #find the average color

z1a = (z1+zavg)/2 #find the average of average and color 1
z2a = (z2+zavg)/2 #find the average of average and color 2

z3 = np.hstack((z1,z1a,zavg,z2a,z2)) #stack them up in order

plt.imshow(z3); #plot
plt.show() #show





for i in range(100): #now we do the same thing 100 times in a for loop

    z1 = np.ones((10,10,3))
    z1[:,:,0] = np.random.rand()
    z1[:,:,1] = np.random.rand()
    z1[:,:,2] = np.random.rand()

    z2 = np.ones((10,10,3))
    z2[:,:,0] = np.random.rand()
    z2[:,:,1] = np.random.rand()
    z2[:,:,2] = np.random.rand()

    zavg = (z1+z2)/2

    z1a = (z1+zavg)/2
    z2a = (z2+zavg)/2

    z3 = np.hstack((z1,z1a,zavg,z2a,z2))

    plt.imshow(z3);
    plt.show()



import numpy as np #libraries
import matplotlib.pyplot as plt

def recursive_average(colors): #make a function
    """
    Compute the recursive average of the given list of colors.

    Parameters:
    - colors: List of color arrays

    Returns:
    - A new list of color arrays containing the recursive averages.
    """
    new_colors = [colors[0]] #make a list which will contain the first color of our input
    for i in range(1, len(colors)): #make a for loop with the range of our input
        avg_color = (colors[i] + new_colors[-1]) / 2.0 #get the average of the color we are on and the last color in the new colors list
        new_colors.extend([avg_color, colors[i]]) #add the average color and the new color to our list
    return new_colors #return the list

def generate_recursive_colors_v2(passes): #make another function to generate 1 or more random colors
    """
    Generate a visualization of 2 random colors and their recursive averages for a number of passes.

    Parameters:
    - passes: Number of times to apply the recursive averaging process

    Returns:
    - An image showing the 2 endpoint colors and their recursive averages.
    """
    # Start with 2 random colors
    colors = [np.ones((10,10,3)) for _ in range(2)] #generate two random colors
    for color in colors:
        color[:,:,0] = np.random.rand() #these are for the r g and b channel of our random colors
        color[:,:,1] = np.random.rand()
        color[:,:,2] = np.random.rand()

    # Apply the recursive averaging for the specified number of passes
    for _ in range(passes):
        colors = recursive_average(colors) #for each of our passes we run the recursive average function

    # Horizontally stack the colors
    result = np.hstack(colors)

    return result

for i in range(5):
    img = generate_recursive_colors_v2(i) #run the recursive average using i of the for loop as our pass parameter
    plt.imshow(img) #plot
    plt.axis('off') #turn of axes
    plt.tight_layout() #make the layout shrunk
    plt.show() #show

import numpy as np #libraries
import matplotlib.pyplot as plt

def recursive_average(colors): #make a new recursive average function

    new_colors = [colors[0]] #use the first color in our color list as the first color in our new colors function
    for i in range(1, len(colors)): #do a for loop for each color in our range
        avg_color = (colors[i] + new_colors[-1]) / 2.0 #average our current color we're on, and the last color in our results list
        new_colors.extend([avg_color, colors[i]]) # add the color we're on and the average color to our result
    return new_colors #send result

def generate_recursive_colors_v2(passes, initial_colors): #do another recursive colors function

    colors = initial_colors.copy() #make a copy of our initial colors input so we can amend it

    for _ in range(passes): #we use the recursive average function to continually average our colors the amount of passes we have
        colors = recursive_average(colors)

    result = np.hstack(colors) #stack our colors

    return result #return our color list

initial_colors = [np.ones((10, 10, 3)) for _ in range(2)] #make two random colors
for color in initial_colors:
    color[:,:,0] = np.random.rand() #random r g and b values
    color[:,:,1] = np.random.rand()
    color[:,:,2] = np.random.rand()

passes_values = [0,1,2,3,4] #make a list of passes values and use them each as inputs for our generate recursive colors function
imgs = [generate_recursive_colors_v2(p, initial_colors) for p in passes_values] #run the function for each of the values in passes values

fig, axs = plt.subplots(1, len(passes_values), figsize=(15, 5)) #set up our graph

for ax, img, p in zip(axs, imgs, passes_values): #set up our labels
    ax.imshow(img)
    ax.axis('off')
    ax.set_title(f'Passes={p}')

plt.tight_layout() #tight layout
plt.show() #show

"""https://lospec.com/palette-list"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import matplotlib
import imageio.v2 as imageio
from PIL import Image

def get_colors_lospec(url): #this function reads images and gets a colormap from the image on the site
    im = imageio.imread(url) #read url into image
    rgb_list = (im/255)[0,:,0:3] #change from rgb 255 to decimal color values
    float_list = list(np.linspace(0,1,len(rgb_list))) #this makes an array evenly spaced between 0 and 1 with the length of our rgb list
    cdict = dict()
    for num, col in enumerate(['red', 'green', 'blue']):
        col_list = [[float_list[i], rgb_list[i][num], rgb_list[i][num]] for i in range(len(float_list))]
        cdict[col] = col_list
    cmp = mcolors.LinearSegmentedColormap('my_cmp', segmentdata=cdict, N=256)
    return cmp #we get a colormap as a result

url = 'https://lospec.com/palette-list/agb-32x.png'
im = imageio.imread(url)
plt.imshow(im); #this is how we use the plt function to display an image

url = 'https://lospec.com/palette-list/moondrom-1x.png'
im = imageio.imread(url)
plt.imshow(im); #same thing different image

z = np.random.randint(0,255,size=(10,10)) #make a random 10 x 10 array, (this is not a 3d color array just one color channel)

z

plt.imshow(z,cmap='jet') #display the array and multiply it by the jet colormap

plt.imshow(z, cmap=get_colors_lospec(url))
plt.colorbar(); #same exact array with a different colormap

x, y = np.mgrid[-5:5:0.05, -5:5:0.05] #we generate two gradients
z = np.sqrt(x**2 + y**2) #multiply each by the formula for a circle

x

y

z = np.sqrt(x**2 + y**2)

z.shape

plt.imshow(x) #our first gradient

plt.imshow(y) #second gradient (vertical)

z #the mathematical result of the circle function

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show() # plot the circle function



x, y = np.mgrid[-5:5:0.05, -5:5:0.05]

z = np.sin(3*y) #what if we do the sin function on a vertical gradient?

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show()

x, y = np.mgrid[-5:5:0.05, -5:5:0.05]

z = np.sin(3*x) #horizontal gradient sin function

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show()

x, y = np.mgrid[-5:5:0.05, -5:5:0.05]

z = np.sin(3*y)*np.sin(3*x)

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show() #sin of 3y times sin of 3x-  the point is we can do mathematical functions with matrices and get differing results



import matplotlib.pyplot as plt
import imageio
from PIL import Image
from skimage.io import imread

def plot(x): #set a default plot function using pyplot
    fig, ax = plt.subplots()
    im = ax.imshow(x,cmap='gray')
    ax.axis('off')
    fig.set_size_inches(20, 20) #regularize the size of the images
    plt.show()

im = imread('https://raw.githubusercontent.com/imageio/imageio-binaries/master/images/imageio_banner.png')

plot(im) #plot the banner from the url

url = "https://upload.wikimedia.org/wikipedia/commons/thumb/5/57/Octopus2.jpg/800px-Octopus2.jpg"

im = imread(url) #read our octopus image from the url into our program

plot(im) #show it using our default plot function

im.shape #find the size of our image, what is the 3?  its the #of color channels

plt.imshow(im[:,:,0],cmap="gray") #this is our red color channel in b and w

plt.imshow(im[:,:,1],cmap="gray") #this is our green color channel, notice the green algae is visible here but not in the green color channel

plt.imshow(im[:,:,2],cmap="gray") #blue color channel, the octopus is darker because it is a more red color in the image

r = im[:,:,0] #make an 2d matrix out of each color channel
g = im[:,:,1]
b = im[:,:,2]

combo = np.hstack([r,g,b]) #stack them horizontally

plt.imshow(combo,cmap="gray") #show our color channels side by side

