# -*- coding: utf-8 -*-
"""Ryan McDaniel Math 24 Lab 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vRHbzVPGdqnMcKXG0KDXAxhJlWiWo-aQ

## Python Basics

### Calculator
"""

# Comments with hashtag, python ignores this

30.34321 + 9.12313 - 3.5567 #Basic Mathematical Functions

3 + 3.0

"""Python will always default to outputting a float when adding a float to an integer."""

2*2 #Multiplication

2**8 #Python writes exponents as "**"

2**123 #This lets us do large problems that normal calculators cannot do

2**12345 #Like this one

import sys
sys.set_int_max_str_digits(100000)
2**45678

8/4 #Division, the result of which is always a float in python

8//4 #Integer Division, divides and outputs an integer.  Always rounds down, and does not give a remainder.

8.0//4.0

8%12 # Gives the remainder of the division of two integers.  In this case the result of 8/12 will be a decimal therefore the remainder is 8

13%12 # 13 divided by 12 is 12R1, this outputs our remainder which is one.

22%12 # Same thing 22/12 is 12R10, therefore the % calculation will output 10

24%12 #No Remainder

"""### Variables"""

apples = 5 #Variables save values to a specific name.  The order is very important.  The left side of the "=" sets the name of the variable, where the right side assigns the variable a value.

"""1. Variables defined outside of functions are "universal variables" they can be accessed from any part of your code.

2. Variables defined within a function are "local" to that function.  They cannot be accessed from outside the function unless you set the function to return the value of that variable and call the function within a universal variable.

3. = and == are two different operators.  = is known as the assignment operator and it is used to assign values to variables.  == checks if the values on both its sides are equivalent.

4. A variable can be defined before it is assigned a value.  You can do this by setting "Variable = None" or by simply typing "Variable" which will create a variable with null value.

5. A variable only saves the most recent value assigned to it.  Doing "x = 4" and then doing "x = 6" in that order will return value 6 whenever the variable is referenced after assigning x the value of 6.  Variables do not save their history.
"""

oranges = 8

total = apples + oranges

"""1. Variables can be assigned value equal to an operation.  In this case that operation is "apples + oranges"

2. The order of the equation is important.  If you do "apples + oranges = total" an error will occur.  This is because variables must be defined on the left side of the assignment operator and the value will be assigned on the right side of the assignment operator.
"""

total #typing the name of a variable which is already defined in your python program will default to the "print(variable_name)" function, which will output its value.

apples**2 # apples squared.  This will output the value but because no variable is assigned to it the value will not be saved anywhere within the program.  It will simply output the value and forget it

cost_per_apple = 0.25 #defining another variable

total_apple_costs = cost_per_apple * apples #defining another variable, it is important to name your variables by convention and make them intuitive for referencing later in your code.
# it is also important so people reading your code can understand it more easily

total_apple_costs # shortcut of the print() function

"""### Vectors"""

# the "import" command will import a library of both variables and functions which will be called in your document

# the "as" command will assign the library a shortened nickname

# to call a function in the library, you write "nickname_of_library.function()" this will tell python to look in the library for the function

# you can write your own libraries or import libraries created by others, such as the libraries here


import numpy as np #numpy is numerical python.  In this case we give it the nickname of np
import matplotlib.pyplot as plt # #matplotlib.pyplot is a library which is used to quickly and easily plot values within python.  We nickname it plt

np.arange(10) #this is calling a function within numerical python called "arange()" the return of the function with only one argument defined is a one dimensional array of ascending integers
              #starting with zero and ending with a size of 10 (or whatever argument you enter into the function) the arange() function requires a minimum of one argument

x = np.arange(10) #now we save the array created by the function as x, notice it does not print the value of x because we used the assignment operator

x # print the value of x

y = 3 * x + 5 # we can do mathematical functions on arrays, when doing so your result will be an array with the output of each value in your array, in the same order as your inputs

y #print y

# x = np.array([133,24,333,4,5,6])
# y = np.array([11,22,33,44,55,66])

x,y #this is defaulting to print function with arguments x and y.  The print function can take as many arguments as you need it to

"""### Plotting"""

plt.plot(x,y) #here we call the "plot()" function contained within the matplotlib.pyplot library.  This function can take lots of arguments, but the first argument defaults to the value on the x axis and the second to y axis

plt.plot(x,y,'.') #including the string '.' as an argument will change the plot function to plot dots on every x and y value contained, rather than a line (which is the default)

plt.plot(x,y,'r.') #r changes the color of the dot to red

plt.plot(x,y,'b--') #b makes the color blue and -- makes the output a dashed line

import matplotlib.pyplot as plt

plt.plot(x,y)

x = np.linspace(0,5,10) # the np.linspace function makes an array with a starting value of 0, and ending value of 5, with 10 seperate points.  The points in the linspace array are evenly spaced between the start and end

x

y = x**2 # square the entire array

plt.plot(x,y) # our output on the plot is a parabolic function

plt.plot(x,y) # plot x and y
plt.title("New Graph of x**2"); # set the title of the plot, displayed above the plot
plt.xlabel("x"); # set the label of the x axis which is displayed below the x axis
plt.ylabel("y"); # label y axis

plt.plot(x,y,label="x squared") # this "label" argument names your line, but the name of the line is not displayed by default
plt.title("Graph of x**2");
plt.xlabel("x");
plt.ylabel("y");
plt.legend() # the legend will show your line(s) color and shape next to their names

x = np.linspace(0, 2, 100) #define a new x, this will overwrite the old value of x

plt.plot(x, x, label='linear') #note that you are not plotting x=x here, rather the x and y are the first two arguments of the plt.plot() function, meaning you are actually ploting y=x
plt.plot(x, x**2, label='quadratic') #y = x squared
plt.plot(x, x**3, label='cubic') #y = x cubed

plt.xlabel('x label')
plt.ylabel('y label')

plt.title("Simple Plot")

plt.legend()

labels = 'Frogs', 'Dogs', 'Cats', 'Birds' #you can assign a variable multiple values, here using a tuple.  This is not the same as an array.  A tuple can store any number of types of values (Boolean, Integer, Float, String)
#within the same variable.  Using no parentheses or brackets defaults to a tuple.  Using parentheses also creates a tuple.  To make a list you have to use brackets.
sizes = [15, 30, 40, 15] #here is a list
explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice (i.e. 'Dogs') another tuple

fig1, ax1 = plt.subplots()
ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)
ax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
plt.show()

"""The main difference between tuples and lists is that you cannot modify a tuple after it is created without redefining it completely.  A list uses more memory for computations but can be edited without redefining."""

import numpy as np
import matplotlib.pyplot as plt
t = np.arange(0.0, 2.0, 0.01)
s = np.sin(2*np.pi*t)

plt.plot(t, s)
plt.title(r'$\alpha_i > \beta_i$', fontsize=20)
plt.text(1, -0.6, r'$\sum_{i=0}^\infty x_i$', fontsize=20)
plt.text(0.5, 0.6, r'$\mathcal{A}\mathrm{sin}(2 \omega t)$',fontsize=15)
plt.xlabel('time (s)')
plt.ylabel('volts (mV)')
plt.show()

"""Plot the following functions from $x = -10$ to $x = 10$

(Hint: np.sin, np.exp)

$y = 10x+7$

$y = -3x-12$

$y=\sin(x)$

$y=e^x$

$y=e^{-x^2}$
"""

x = np.linspace(-10,10,201)

x

plt.plot(x, 10 * x + 7)

plt.plot(x, -3 * x - 12)

plt.plot(x, np.sin(x))

plt.plot(x, np.exp(x))

plt.plot(x, np.exp(-x**2))

"""Pick out a plot of your choice from [here](https://matplotlib.org/stable/gallery/index.html), copy the code to this notebook, run, and document to the best of your abilities."""

import matplotlib.pyplot as plt
import numpy as np

from matplotlib.colors import Normalize
from matplotlib.markers import MarkerStyle
from matplotlib.text import TextPath
from matplotlib.transforms import Affine2D

SUCCESS_SYMBOLS = [
    TextPath((0, 0), "â˜¹"),
    TextPath((0, 0), "ðŸ˜’"),
    TextPath((0, 0), "â˜º"),
]

N = 25
skills = np.random.uniform(5, 80, size=N) * 0.1 + 5
takeoff_angles = np.random.normal(0, 90, N)
thrusts = np.random.uniform(size=N)
successful = np.random.randint(0, 3, size=N)
positions = np.random.normal(size=(N, 2)) * 5
data = zip(skills, takeoff_angles, thrusts, successful, positions)

cmap = plt.colormaps["jet"]
fig, ax = plt.subplots()
fig.suptitle("Throwing success", size=14)
for skill, takeoff, thrust, mood, pos in data:
    t = Affine2D().scale(skill).rotate_deg(takeoff)
    m = MarkerStyle(SUCCESS_SYMBOLS[mood], transform=t)
    ax.plot(pos[0], pos[1], marker=m, color=cmap(thrust))


plt.show()

t = np.arange(0.0, 2, 0.01)
s = np.sin(2*np.pi*t)

fig, ax = plt.subplots()

ax.plot(t, s, color='black')
ax.axhline(0, color='black')

ax.fill_between(t, 1, where=s > 0, facecolor='green', alpha=.5)
ax.fill_between(t, -1, where=s < 0, facecolor='red', alpha=.5)

plt.show()

t = np.arange(0.0, 2, 0.01)
s = np.sin(2*np.pi*t)

fig, ax = plt.subplots()

ax.plot(t, s, color='black')
ax.axhline(0, color='black')

ax.fill_between(t, s, where=s > 0, facecolor='green', alpha=.5) # changing the second argument to s will only fill the area under the curve of s
ax.fill_between(t, s, where=s < 0, facecolor='red', alpha=.5)

plt.show()

t = np.arange(0.0, 2, 0.01) #also if you input a value smaller than the range for the third argument it spaces each point out by that much
s = np.sin(2*np.pi*t)

fig, ax = plt.subplots()

ax.plot(t, s, color='black')
ax.axhline(0, color='black')

ax.fill_between(t, s, where=s > 0, facecolor='green', alpha=.5) # changing the second argument to s will only fill the area under the curve of s
ax.fill_between(t, s, where=s < 0, facecolor='red', alpha=.5)

plt.show()

t = np.arange(0.0, 2, 0.01)
s = np.sin(2*np.pi*t)
u = np.exp(-t**2)

fig, ax = plt.subplots()

ax.plot(t, s, color='blue', alpha=.5)
ax.plot(t, u, color='orange')
ax.axhline(0, color='gray')

ax.fill_between(t, s, u, where=s > u, facecolor='green', alpha=.3) # changing the second argument to s will only fill the area under the curve of s
ax.fill_between(t, s, u, where=u > s, facecolor='red', alpha=.3)

plt.show()

"""### Graphics Output"""

from IPython.core.display import display, HTML #import the HTML and display libraries to allow python to display html

display(HTML('<h1>Hello World!</h1>'))

"""### Numpy - Numerical Python"""

import numpy as np

np.random.random() #calls the random function from the random library within numerical python.  function returns a random float between 0 and 1

np.random.random() > 0.5; # check if a random number that we draw (not the previous one) is greater then 0.5, if so output true else output false.  Ending the line with a semicolon forces python not to call the print function

r = np.random.random(); print(r); r >0.5 # lines are separated by semicolons.  Since the last line " r > 0.5" has no semicolon it will call the print() function

"""Previous box saves a random number as variable "r" and prints the value, and prints whether that value is greater than 0.5 or not"""

r # variable remains saved for future reference, it will not be a random number each time this is called, but the same number which was randomly generated is now stored in the variable

r > 0.5

def flip_coin(): # define a function called flip_coin(), because this function simply calls the print function, it will not return a usable value
    if np.random.random() > 0.5: # this function will generate a random float between 0 and 1 every time it is called, and simply print heads if it is > 0.5 or print tails otherwise.
    # a function like this is of little use when the values cannot be saved, lets make a more versatile function later
        print("Heads")
    else:
        print("Tails")

flip_coin() #calls the previously defined function

np.random.randint(15,20) #randint will only generate a random integer.  the arguments are the min (inclusive) and max (exclusive) for that integer

def coin():
  return np.random.randint(2) #defining only one argument will set the min value equal to zero and the max value equal to "argument - 1", in other words the number of possible values that can be generated is the argument

coin() # call the coin() function

display(HTML('<img src="https://random-ize.com/coin-flip/us-quarter/us-quarter-front.jpg">')) #we can display images which have HTML links using display(HTML('INSERT HTML HERE AS A STRING'))

heads = 'https://random-ize.com/coin-flip/us-quarter/us-quarter-front.jpg' #define the links as strings.  IDK why he did it like this instead of including the <img src=LINK> part of the HTML as a string
tails = 'https://random-ize.com/coin-flip/us-quarter/us-quarter-back.jpg' # doing it like this means you have to concatenate the HTML within the function arguments



def show_img(img): # i guess it makes sense because you can paste the link here without having to input the html part of the link in your argument
  display(HTML('<img src=' + img + '>'))

show_img(heads)

show_img(tails)

def flip_coin(): # now we're calling two functions within the flip_coin() function

    if coin(): #coin outputs true if > 0.5, so this is an if True: statement
        show_img(heads) #shows the heads image if true
    else:
        show_img(tails) #otherwise shows tails

flip_coin()

for i in range(5): # a for loop with length of 5, will call flip_coin() five times
    flip_coin()

"""# Cards"""

card_url_head = "https://www.improvemagic.com/wp-content/uploads/2020/11/" #this piece of url will be used to concatenate strings to display the correct corresponding image url for each card
card_url_tail = ".png"

suit = ['k','p','s','l'] #clubs,spades,hearts,diamonds, this is a library of each suit, card is a library of each card
card = ['a','2','3','4','5','6','7','8','9','10','j','q','k']

i = np.random.randint(4) #i represents the four possible suits
j = np.random.randint(13) #j represents the thirteen ranks

i,j #print i and j

suit[i] #this is referencing the "ith" position in the library.  Depending which number i is will correspond to a different suit

card[j] #same thing with rank

def card_image(card_number): #now we make a function to reduce the absolute numerical value of a card 1-52 into a two value number i being suit and j being rank

    i = card_number//13 #since // gives the integer value of division with no remainder, this will have the effect of splitting the 52 cards into 4 seperate categories
    #1-13,14-26,27-39,40-52 meaning it can tell us which suit a card is
    j = card_number%13 #since % gives the remainder without the result of division, this will have the effect of making cards 1,14,27,and 40 the same value, which we will assign the value of 'Ace', ditto for the rest
    #thus this returns the rank of the card

    return suit[i]+card[j] #now we use i and j to reference the previously created lists of suit and rank at positions which correspond to the suit and rank of each card, and return a specific string for each
    #we will concatenate these strings into the url

card_image(3) #inputting the absolute value to the card_image() function will give us its name and rank

print(card_image(13),card_image(26),card_image(39),card_image(52)); #this should print all card of the same rank, since the same ranks will always be separated by 13 exactly in absolute value

img = card_url_head + card_image(3) + card_url_tail

"""img just concatenates the whole url"""

img

show_img(img) #show_img was the function for displaying HTML images that we defined previously

for i in range(52): #for loop displaying every card
    img = card_url_head + card_image(i) + card_url_tail
    show_img(img)

import random #random is already in the numpy library if you need it you can just do np.random rather than importing it directly

def initialize_deck():
    #Create and shuffle a deck of 52 cards represented by numbers 0-51.
    deck = list(range(52))
    random.shuffle(deck)
    return deck

def draw_cards(deck, top_index, num=5):
    drawn_cards = deck[top_index:top_index + num]
    return drawn_cards, top_index + num

# Initialize and shuffle the deck
deck = initialize_deck()
top_index = 0  # Start at the beginning of the deck

deck

# Draw 5 cards for a poker hand
hand, top_index = draw_cards(deck, top_index, 5)

hand

hand, top_index = draw_cards(deck, top_index, 5)

hand

# Display the hand
for card_number in hand:
    img_url = card_url_head + card_image(card_number) + card_url_tail
    show_img(img_url)

def show_hand(hand):
    images_html = ''.join([f'<img src="{card_url_head + card_image(card_number) + card_url_tail}" style="display:inline-block; margin:5px;" />' for card_number in hand])
    display(HTML(images_html))

show_hand(hand)





"""# Rank Hand"""

def evaluate_hand(hand):
    rank_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'j': 11, 'q': 12, 'k': 13, 'a': 14}
    suits = ['k', 'p', 's', 'l']  # clubs, spades, hearts, diamonds

    # Convert the hand to a list of (rank, suit) tuples
    converted_hand = [(rank_values[card[card_number % 13]], suits[card_number // 13]) for card_number in hand]
    converted_hand.sort()

    rank_counts = {rank: 0 for rank in rank_values.values()}
    suit_counts = {suit: 0 for suit in suits}
    for rank, suit in converted_hand:
        rank_counts[rank] += 1
        suit_counts[suit] += 1

    # Check for flush
    is_flush = max(suit_counts.values()) == 5

    # Check for straight and royal flush
    rank_sequence = [rank for rank, _ in converted_hand]
    is_straight = all(rank_sequence[i] - rank_sequence[i - 1] == 1 for i in range(1, 5))
    is_royal = is_straight and rank_sequence[0] == 10

    # Check for other hand types
    pairs = sum(1 for count in rank_counts.values() if count == 2)
    three_of_a_kind = 3 in rank_counts.values()
    four_of_a_kind = 4 in rank_counts.values()

    if is_royal and is_flush:
        return "Royal Flush"
    elif is_straight and is_flush:
        return "Straight Flush"
    elif four_of_a_kind:
        return "Four of a Kind"
    elif three_of_a_kind and pairs == 1:
        return "Full House"
    elif is_flush:
        return "Flush"
    elif is_straight:
        return "Straight"
    elif three_of_a_kind:
        return "Three of a Kind"
    elif pairs == 2:
        return "Two Pair"
    elif pairs == 1:
        return "One Pair"
    else:
        return "High Card"



# Initialize and shuffle the deck
deck = initialize_deck()
top_index = 0  # Start at the beginning of the deck

hand, top_index = draw_cards(deck, top_index, 5)


print(evaluate_hand(hand))
show_hand(hand)



for i in range(10):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)


    print(evaluate_hand(hand))
    show_hand(hand)



for i in range(100):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)

    if evaluate_hand(hand) == "Two Pair":
        print("Winner!")
        show_hand(hand)



for i in range(1000):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)

    if evaluate_hand(hand) == "Flush":
        print("Winner!")
        show_hand(hand)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# # Initialize and shuffle the deck
# deck = initialize_deck()
# top_index = 0  # Start at the beginning of the deck
# 
# hand, top_index = draw_cards(deck, top_index, 5)
# 
# if evaluate_hand(hand) == "Royal Flush":
#     print("Winner!")
#     show_hand(hand)

for i in range(1000000):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)

    if evaluate_hand(hand) == "Royal Flush":
        print("Winner!")
        show_hand(hand)



wins = 0
N = 10000000

for i in range(N):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)

    if evaluate_hand(hand) == "Royal Flush":
        wins += 1
        print("Winner!")
        show_hand(hand)

wins/N

